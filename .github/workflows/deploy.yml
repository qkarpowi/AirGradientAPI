name: Deploy

on:
  push:
    branches: [ master ]

env:
  REGISTRY: ${{ vars.DOCKER_REGISTRY }}
  IMAGE_NAME: airgradientapi

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'
        
    - name: Restore local tools
      run: dotnet tool restore
    
    - name: Run EF Migrations
      run: |
        dotnet ef database update --project AirGradientAPI --connection "${{ secrets.DATABASE_CONNECTION_STRING }}"
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3      
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./AirGradientAPI
        file: ./AirGradientAPI/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        
    - name: Update Portainer container
      shell: bash
      run: |
        set -euo pipefail
        
        PORTAINER_BASE="${{ vars.PORTAINER_URL }}/api"
        ENDPOINT_ID="${{ vars.PORTAINER_ENDPOINT_ID }}"
        SERVICE_ID="${{ vars.PORTAINER_SERVICE_ID }}"
        
        # 1) Get Portainer JWT
        TOKEN=$(curl -sS -X POST "${PORTAINER_BASE}/auth" \
          -H "Content-Type: application/json" \
          -d "{\"Username\":\"${{ secrets.PORTAINER_USERNAME }}\",\"Password\":\"${{ secrets.PORTAINER_PASSWORD }}\"}" \
          | jq -r '.jwt')
        
        if [[ -z "${TOKEN}" || "${TOKEN}" == "null" ]]; then
          echo "::error::Failed to obtain Portainer token"
          exit 1
        fi
        AUTH_HDR="Authorization: Bearer ${TOKEN}"
        
        # 2) Read current service (to get Version.Index and Spec)
        SVC_JSON=$(curl -sS -H "${AUTH_HDR}" \
          "${PORTAINER_BASE}/endpoints/${ENDPOINT_ID}/docker/services/${SERVICE_ID}")
        
        VERSION=$(jq -r '.Version.Index' <<<"${SVC_JSON}")
        SPEC=$(jq -c '.Spec' <<<"${SVC_JSON}")
        
        if [[ -z "${VERSION}" || "${VERSION}" == "null" ]]; then
          echo "::error::Could not read service Version.Index"
          exit 1
        fi
        
        # 3) Build updated Spec safely with jq
        UPDATED_SPEC=$(jq -c \
          --arg image "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" \
          --arg cs "${{ secrets.DATABASE_CONNECTION_STRING }}" \
          --arg aspnet "Production" \
          --arg otel_ep "${{ vars.OTEL_EXPORTER_OTLP_ENDPOINT }}" \
          --arg otel_hdr "${{ secrets.OTLP_AUTH_TOKEN }}" \
          '
          .TaskTemplate.ContainerSpec.Image = $image
          | .TaskTemplate.ContainerSpec.Env =
              ["CONNECTION_STRING=\($cs)",
               "ASPNETCORE_ENVIRONMENT=\($aspnet)",
               "OTEL_EXPORTER_OTLP_ENDPOINT=\($otel_ep)",
               "OTEL_EXPORTER_OTLP_HEADERS=\($otel_hdr)"]
          | .TaskTemplate.ForceUpdate = ((.TaskTemplate.ForceUpdate // 0) + 1)
          ' <<<"${SPEC}")
        
        # 4) Update the service (POST + version query). registryAuthFrom=spec helps private pulls.
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o /tmp/update.out \
          -X POST "${PORTAINER_BASE}/endpoints/${ENDPOINT_ID}/docker/services/${SERVICE_ID}/update?version=${VERSION}&registryAuthFrom=spec" \
          -H "${AUTH_HDR}" \
          -H "Content-Type: application/json" \
          --data "${UPDATED_SPEC}")
        
        if [[ "${HTTP_CODE}" != "200" ]]; then
          echo "::error::Service update failed (HTTP ${HTTP_CODE})"
          cat /tmp/update.out
          exit 1
        fi
        
        echo "âœ… Container updated to use ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
